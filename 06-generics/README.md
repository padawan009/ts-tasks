# Секция 6 - Дженерики

Дженерики дают возможность создавать компоненты, работающие с разными
типами данных. Простейшим примером дженерика будет один из вариантов
объявления массива в TS, которые мы рассматривали в первом уроке:

```ts
let isArrOfNum: Array<number> = [1, 2, 3, 4, 5]
```

Синим цветом выделен именно дженерик.

Теперь рассмотрим как работает дженерик "под капотом" Array:

```ts
interface Array<T> {
  push(...items: T[]): number
  [n: number]: T
}

//Интерфейс Array сильно упрощен для наглядности
```

Если говорить простым языком то тип из дженерика **T** присваивается
каждому элементу массива, а также всем его методам.

## Дженерики в функциях

В примере ниже мы рассмотрим в каких случаях могут быть необходимы
дженерики:

Создадим функцию identity, которая будет возвращать переданное ей
значение:

```ts
function identity(arg: number): number {
  return arg
}
```

Для того, чтобы сделать эту функцию более универсальной, можно
использовать тип any:

```ts
function identity(arg: any): any {
  return arg
}
```

Однако, при таком подходе мы не будем знать тип возвращаемого функцией
значения.

В typescript мы можем передавать в функцию не только аргументы, но также
и типы. Для этого нам необходимо добавить скобки \<\> после названия
функции и передать в них Type. Теперь мы можем указывать этот тип как
для аргументов так и для результата функции.

```ts
function identity<Type>(arg: Type): Type {
  return arg
}
```

При необходимости, мы можем передать в функцию сразу несколько типов:

```ts
function identity<T, U>(value: T, message: U): T {
  console.log(message)
  return value
}
```

### Дженерики в стрелочных функциях

Казалось бы что может быть проще чем пользуясь примером выше написать
стрелочную функцию:

```ts
const identity = <Type>(arg: Type): Type => {
  return arg
}
```

Однако есть "подводные камни" которые впоследствии могут стать причиной
ошибки в коде.

JSX код использует такие же скобки для элементов верстки и для
компонентов (в случае если вы разрабатываете на React).

Избежать таких неприятностей можно несколькими способами, но вам будет
достаточно запомнить простой лайфхак с запятой:

```ts
const identity = <Type,>(arg: Type): Type => {
  return arg
}
```

## Ограничения дженериков. Generic Constraints

Иногда нужно как-то ограничить тип, принимаемый дженериком. Покажу на
реальном примере.

Допустим, у нас есть функция для получения значения свойства length
аргумента:

```ts
function getLength<T>(arg: T): number {
  return arg.length
}
```

Если вы попробуете ее скомпилировать, получите ошибку:

```ts
    Property 'length' does not exist on type 'T'.
```

Происходит это потому, что TypeScript не знает, есть ли у передаваемого
аргумента свойство length. Это легко исправить с помощью Generic
Constraint --- ограничения дженерика. Создадим тип и укажем функции, что
при типизации она может принимать только такой тип, который имеет
свойство length типа number:

```ts
interface Lengthwise {
  length: number
}

function getLength<T extends Lengthwise>(arg: T): number {
  return arg.length
}
```

Ошибка пропадет, а пример заработает. При этом разработчик, использующий
функцию, будет точно понимать, какой аргумент требуется в нее передать.

```ts
getLength(['Я', 'люблю', 'Тинькофф']) === 3
getLength('Я люблю Тинькофф') === 16
getLength(1027739642281) // Ошибка, у number нет свойства length
```

Какой еще может быть практический пример? Давайте напишем функцию,
которая принимает в себя объект и ключ, а выдает значение из переданного
объекта по ключу:

```ts
    function getPropertyValue<Obj, Key extends keyof Obj>(...) { … }
    // тип Key ограничен типом keyof Obj
```

В этом примере также показана возможность ограничения типа,
используемого в объявлении функции, с помощью уже имеющегося параметра:

```ts
const developer = {
  name: 'Sergey Vakhramov',
  nickname: 'vakhramoff',
  website: 'vakhramoff.ru',
}

getPropertyValue(developer, 'nickname') === 'vakhramoff'
getPropertyValue(developer, 'age') // Ошибка, у объекта в переменной developer нет свойства age
```

## Дженерики в классах

Зачем может понадобиться обобщать классы? Уже на этапе разработки мы
часто знаем, что один и тот же класс можно использовать для обслуживания
разных данных. Например, выпадающему списку можно дать массив строк для
отображения простого контента, а можно передать массив шаблонов для
отрисовки сложного. Дженерики помогут описать такой класс.

Для упрощения представлю класс IdentityClass.

Код на JavaScript:

```ts
class IdentityClass {
  constructor(value) {
    this.value = value
  }

  getIdentity() {
    return this.value
  }
}
```

Тот же самый класс будет выглядеть намного понятнее с TypeScript. Для
начала опишем интерфейс:

```ts
interface IdentityGetter<Type> {
  getIdentity(): Type
}
```

Теперь напишем класс, который реализует наш интерфейс:

```ts
class IdentityClass<T> implements IdentityGetter<T> {
  constructor(private readonly value: T) {
    this.value = value
  }

  getIdentity(): T {
    return this.value
  }
}
```
