# Секция 3 - Функции

В JS функции, в основном, используются для работы с данными. TS
позволяет определять типы как для входных (input), так и для выходных
(output) значений функции.

## Аннотации типа параметров

При определении функции можно указать, какие типы параметров она
принимает:

```ts
function greet(name: string) {
  console.log(`Hello, ${name.toUpperCase()}!`)
}
```

## Вот что произойдет при попытке вызвать функцию с неправильным аргументом:

```ts
greet(42)

// ОШИБКА: Аргумент типа 'number' не может быть присвоен параметру типа 'string'
```

_Обратите внимание_: количество передаваемых аргументов будет
проверяться даже при отсутствии аннотаций типа параметров.

## Аннотация типа возвращаемого значения

Также можно аннотировать тип возвращаемого функцией значения:

```ts
function getFavouriteNumber(): number {
  return 26
}
```

Чтобы показать, что функция ничего не возвращает используется ключевое
слово **void** - отсутствие какого-либо значения. В примере ниже
возвращаемый тип **void** объявлен явно, хотя опять же - TypeScript
понимает это, а значит в этом нет необходимости.

```ts
const logMessage = (msg: string): void => {
  console.log('Логи: ' + msg)
}

logMessage('Hello world!')
// Логи: Hello world!
```

Как и в случае с аннотированием переменных, в большинстве случаев TS
может автоматически определить тип возвращаемого функцией значения на
основе инструкции return.

## Анонимные функции

Анонимные функции немного отличаются от обычных. Когда функция появляется в месте, где TS может определить способ ее вызова, типы параметров такой функции определяются автоматически.

Вот пример:

```ts
// Аннотации типа отсутствуют, но это не мешает `TS` обнаруживать ошибки
const names = ['Alice', 'Bob', 'John']

// Определение типов на основе контекста вызова функции
names.forEach(function (s) {
  console.log(s.toUppercase())
  // Property 'toUppercase' does not exist on type 'string'. Did you mean 'toUpperCase'? Свойства 'toUppercase' не существует в типе 'string'. Вы имели ввиду 'toUpperCase'?
})

// Определение типов на основе контекста также работает для стрелочных функций
names.forEach((s) => {
  console.log(s.toUppercase())
  // Property 'toUppercase' does not exist on type 'string'. Did you mean 'toUpperCase'?
})
```

Несмотря на отсутствие аннотации типа для s, TS использует типы функции
forEach, а также предполагаемый тип массива для определения типа s. Этот
процесс называется определением типа на основе контекста (contextual
typing).

## Подпись функции

Если мы хотим объявить переменную-функцию, но не определять ее
(обозначить, что она делает), то мы можем использовать подпись функции.
В примере ниже функция sayHello должна соответствовать подписи после
двоеточия:

```ts
// Объявим переменную sayHello и зададим ей подпись: принимает на вход строку и ничего не возвращает
let sayHello: (name: string) => void

// Теперь определим функцию, соответствующую подписи
sayHello = (name) => {
  console.log('Привет, ' + name)
}

sayHello('Кирилл') //Привет, Кирилл
```
